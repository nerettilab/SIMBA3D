# OVERVIEW

This example demonstrates how to create a multi-scale warmstart task on a 
simulated data set.

This tutorial is similiar to the 'multiscale_example_single_cell_M19' example
but there is the added step of creating a simulated data matrix from a ground
truth curve stored in the 'data/ground_truth_curves/double_spiral_curve.npy'.

It is useful to use a simulated data set because in real situations the 
groundtruth shape of the 3D structure is unknown. This allows the investigator
to judge how robust the algorithm is to noise and other data artifacts.

# FIRST create a simulated data matrix

The 'create_simulated_data.py' script will read the 3D curve stored in 
'data/ground_truth_curves/double_spiral_curve.npy' and will resample it to the
desired number of bins and create a simulated pairwise interaction matrix using
independent Poission random variables. The means are computed using the 
Varoquaux model. 

The script will create images of the ground truth curve, and the simulated
data matrix. The data matrix plot label non-zero simply shows which entries are
greater than zero. This helps gauge the amound of sparcity in the simulated 
data.

# NEXT set up the multiscale warmstart task

The 'create_multiscale_warmstart_tasklist.py' script will set up a multiscale 
warmstart tasklist to estimate the structure. First it will create a set
of downsampled matrices respectively labeled with the corresponding matrix 
dimensions. Then the script will create a warmstart task list by iteratively
reading the downsampled inputs from the smallest to the largest.

In the first iteration, the initialized curve is randomly generated using
guassian noise. Each subsequence run using the warmstarts will initialize
using the previous iteration's run. To setup the multiscale tasklist, use the 
following command:

> python create_multiscale_warmstart_tasklist.py

# THEN run the tasklist

After running the script, the data directory will contain downsampled matrices
and a tasklist file called 'multiscale_warmstart_tasklist.json' will be made.
This tasklist provides the sequential instructions for SIMBA3D to run the
multiscale warmstarts. To collect experimental results, use the following
command:

> simbda3d -r simulated_data_multiscale_warmstart_tasklist.json

At this point, simba3d will begin collecting the data results and saving the
intermediate runs to the output directory. The intermediate runs are the
solutions to the downsampled verions of the data. The tasklist setup script
'create_multiscale_warmstart_tasklist.py' will randomly create a unique uuid
each time it is run. This uuid is appended to the output name. If you try and 
rerun the experiment without clearing the output, then simba3d will check to 
see if the task has already been collected. It will skip over the task if the 
task in the ouput directoy has the same uuid. This is useful for resuming in the
event of an interuption. The current subtask will be lost, but the intermediate 
tasks that were completed will be kept.

# viewing the results

The low resolution initial runs should be collected rather quickly. In the
case demonstrate in this example the smallest resolution is 40x40. That can
be viewed with the 'simba3d-disp' command (make sure to replace the [UUID] with
the uuid generated by the 'create_multiscale_warmstart_tasklist.py' script):

> simba3d-disp -i results/simulated_data_[UUID]_40.npz

The sequential list of runs will use the solution from the previous resolution
to initialize the next run. The next higher resolution is 80, which can be 
viewed with the following command:

> simba3d-disp -i results/simulated_data_[UUID]_80.npz

The final solution may take some time to complete. It has a resolution of 1280 
and can be viewed using the following command:

> simba3d-disp -i results/simulated_data_[UUID]_1280.npz

The display command can now plot multiple curves even if the dimensions do not 
match. It can also align the the curves with respect to a single curve or
a result output file. To plot all of the solutions and align them to the ground
truth, use the following command:

> simba3d-disp -c data/ground_truth_curves/double_spiral_curve.npy -i results/simulated_data_*.npz 

# creating a python summary report script

Here are some things I think you might want to do with the results from
experiments like the one collected in this example.

## You might want to find out the total computation time over several tasks

Here are some ways you can find out the total computation time.

- THE BRUTE FORCE METHOD: manually copy and paste it from the intermediate 
output reports and add them together.
  - The output reports have a computation_time key which stores the time it
  took that subtask to run in seconds.
  - You can print it out with the following command:
  - Also, when the simba3d is done running your tasklist it will tell you the 
  amount of time that elapsed.
  
> simba3d-print -i path/to/output_result_file.npz computation_time

- CREATE/MODIFY A PYTHON SCRIPT:
  - If you have a lot of files don't want to manually go through each one, you
  could create a python script that will loop through a list of files and print 
  out computation time.
  - the 'compute_total_computation_time.py' will loop through a list of 
  manually entered output files, extract the 'computation_time' key value, sum 
  them up, and report the total time. 
  - In this example it is a script that is calles as:

> python compute_total_computation_time.py

## You might want to plot the final solution curve aligned with the ground truth

When plotting the 3D curve, you may wish to remove the translation, scale,
and rotational variability to yeild a more consistent plot. SIMBA3D comes with 
some tools that can address these shape similiarity transformations. It also
comes with some tools for plotting the results more intuitively. You can also 
plot the outputs using matplotlib directly if you do not like the plotting
wrappers made for SIMBA3D. The 'plot_aligned_to_ground_truth.py' script will
load the final result, align it to the ground truth curve, and create images
of the estimated curve to help compare with the final estimated curve.




